{
  "hash": "577c42c76a0442139bfa5a1c8e6a66eb",
  "result": {
    "markdown": "---\ntitle: \"Spotify With Machine Learning\"\ndescription: \"Exploring Spotify Music with Different Machine Learning Algorithms\"\nauthor:\n  - name: Erica Dale\n    url: http://ericamarie9016.githubt.io\n    affiliation: MEDS\n    affiliation-url: http://ucsb-meds.github.io\ndate: 2022-12-09\nformat:\n  html:\n    code-fold: false\n    code-summary: \"Show the code\"\ncode-overflow: wrap\ncode-block-bg: true\ncode-block-border-left: \"#6B5A75\"\ncategories: [MEDS, Machine Learning, R, Spotify, Music, Tutorial]\ncitation: \n  url: http://ericamarie9016.github.io/2023-02-22-spotify\nimage: music.jpeg\n---\n\n\n## Introduction\n\nThis fun project will use my personal Spotify music, along with my friend Kiran's, with the goal to build several machine learning algorithms that will determine whose music library a song belongs to. I will explore several candidate models (k nearest neighbors, bagging, and random forest) to predict this binary outcome. To begin, the code to access your own Spotify account is included!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(spotifyr)         # Spotify API interaction\nlibrary(here)             # Set file location\nlibrary(knitr)            # Creates nice tables\nlibrary(tidyverse)        # Data manipulation and visualization\nlibrary(tidymodels)       # Building machine learning models\nlibrary(rsample)          # Prepocessing datasets for machine learning\nlibrary(readr)            # Reads structured data files\nlibrary(dplyr)            # Data manipulation and transformation\nlibrary(ggplot2)          # Visualizations and plots\nlibrary(rpart)            # Decision tree algorithms\nlibrary(caret)            # Tools for machine learning models\nlibrary(rpart.plot)       # Visualization of decision trees\nlibrary(vip)              # Computes variable importance\nlibrary(pdp)              # Visualization of partial dependence plots\nlibrary(parsnip)          # Creating and tuning machine learning models\nlibrary(ipred)            # Bagging and bootstrapping for ensemble models\nlibrary(baguette)         # Building deep learning models\n```\n:::\n\n\n### Access the Spotify API\n\nTo access the Spotify API, follow the link to Spotify For Developers (https://developer.spotify.com/) and follow these instructions:\n\n-   Select \"Create a Client ID\"\n\n-   Fill out form to create an app\n\n-   On dashboard page, click new app\n\n-   App's dashboard page will have Client ID\n\n-   Click \"Show Client Secret\"\n\n-   Use the below code with your client ID and Client Secret in R!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.setenv(SPOTIFY_CLIENT_ID = 'your_token')\nSys.setenv(SPOTIFY_CLIENT_SECRET = 'your_token')\n \naccess_token <- get_spotify_access_token(\n   client_id = Sys.getenv(\"SPOTIFY_CLIENT_ID\"),\n   client_secret = Sys.getenv(\"SPOTIFY_CLIENT_SECRET\")\n)\n```\n:::\n\n\nI downloaded my liked songs, but the built-in function with the {spotifyr} package has a limit to download only 20 songs at a time. Below I wrote a loop to continue adding all of my liked songs into a dataframe.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsongs_data <- data.frame()     # create base empty data frame\noffset <- 0                    # starting point for spotify function offset\nlimit <- 20                    # maximum download at a time\n\nwhile(TRUE) {                  # loop through all liked songs\n\n  tracks <- get_my_saved_tracks(limit = limit, offset = offset)\n  \n  if(length(tracks) == 0) {    # setting when to stop the loop\n    break\n  }\n  \n  # add tracks into previously created dataframe\n  songs_data <- rbind(songs_data, tracks)  \n  \n  offset <- offset + limit     # reset the loop to start at the next 20\n\n}\n```\n:::\n\n\nThere are other functions to play with inside this {spotifyr} package! I will not be exploring these further in this blog post.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbearicas_recent <- get_my_recently_played()\nbearicas_top <- get_my_top_artists_or_tracks()\nunique(bearicas_top$genres)\n```\n:::\n\n\nThis initial data downloaded is not very exciting to play with. This data frame is mostly important to pull out the song ID column, and use that to connect back with Spotify's API for downloading the specific audio features for each song. This function has a maximum download of 100 rows at a time so I created another loop below to download all the related audio features and bind the columns to the initial dataframe.\n\n\n::: {.cell}\n\n```{.r .cell-code}\naudio_features <- data.frame()        # create base empty data frame\n\nfor(i in seq(from = 1, to = nrow(songs_data), by = 100)) { \n  \n  if (i > nrow(songs_data)) {         # setting when to stop the loop\n    break\n  }\n  \n  row_index <- i:(i + 99)             # collect 100 rows starting from i\n  \n  # pull out features for set rows\n  audio <- get_track_audio_features(songs_data$track.id[row_index])\n  \n  # add features to dataframe\n  audio_features <- rbind(audio_features, audio)\n}\n\n# will read in by 100, so may have NA's from the last loop\naudio_features <- drop_na(audio_features)\n\n# create data frame with songs and fun features!\nericas_audio <- cbind(audio_features, \n                      track.name = songs_data$track.name,\n                      track.popularity = songs_data$track.popularity) |> \n  select(-c(uri, track_href, analysis_url, type))     # remove rows\n  \n# save as csv to share\nwrite_csv(ericas_audio, \"ericas_audio.csv\")\n```\n:::\n\n\nMy friend Kiran and I swapped data, which I will use to create a series of machine learning models to compare our music tastes. The goal is to create a model that can predict, using the audio features whose playlist it is from. I will go through four different types of models and at the end compare the metrics of each to decide which was most effective! The outcome variable will be the binary option of Kiran or Erica, set as listener_id.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nericas_audio <- ericas_audio |> \n  mutate(listener_id = \"erica\")\n\nkirans_audio <- read_csv(\"kiran_audio.csv\") |>  # get partner's data as csv\n  mutate(listener_id = \"kiran\")\n\n# combine datasets\ntotal_audio <- rbind(ericas_audio, kirans_audio) |> \n  mutate(listener_id = as.factor(listener_id))\nwrite_csv(total_audio, \"total_audio.csv\")\n```\n:::\n\n\nAll of these previous steps culminate to this total_audio.csv file that I have previously saved and set aside, since I did not want to share my private Spotify information at the beginning.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntotal_audio <- read_csv(here(\"posts\", \"2023-02-22-spotify\", \"total_audio.csv\")) |> \n    mutate(listener_id = as.factor(listener_id))\n```\n:::\n\n\n### Data Exploration!\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ntotal_audio %>%\n  arrange(desc(instrumentalness)) |> \n  select(instrumentalness, track.name, track.popularity, listener_id) |> \n  rename('track name' = track.name,\n         'track popularity' = track.popularity,\n         'listener' = listener_id) |> \n  head(6) |> \n  kable()\n```\n\n::: {.cell-output-display}\n| instrumentalness|track name                | track popularity|listener |\n|----------------:|:-------------------------|----------------:|:--------|\n|            0.971|Slow Blues - Instrumental |               38|kiran    |\n|            0.946|Orange                    |               42|kiran    |\n|            0.935|Ylang Ylang               |               61|kiran    |\n|            0.924|Atlas                     |               46|kiran    |\n|            0.924|Defect                    |               19|kiran    |\n|            0.918|Master Tea                |                0|erica    |\n:::\n:::\n\n\nSurprised to find out that the top instrumental songs belonged mostly to Kiran's playlist, I mostly listen to music with strong drums and little lyrics so expected that I'd be in the top.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ntotal_audio %>%\n  arrange(desc(acousticness)) |> \n  select(acousticness, track.name, track.popularity, listener_id) |> \n  rename('track name' = track.name,\n         'track popularity' = track.popularity,\n         'listener' = listener_id) |> \n  head(6) |> \n  kable()\n```\n\n::: {.cell-output-display}\n| acousticness|track name                       | track popularity|listener |\n|------------:|:--------------------------------|----------------:|:--------|\n|        0.994|Pachamama                        |               58|erica    |\n|        0.979|Flowers                          |               57|erica    |\n|        0.978|All We Do                        |               56|erica    |\n|        0.973|Whatever's Written in Your Heart |               29|kiran    |\n|        0.942|The Forsaken Waltz               |               32|kiran    |\n|        0.934|The View                         |                8|erica    |\n:::\n:::\n\n\nAlthough more of the top acoustic songs belonged in my playlist, Kiran listens to much louder music than me apparently.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nggplot(total_audio, aes(x = track.popularity, y = listener_id)) +\n  geom_boxplot(aes(fill = listener_id), color = \"#000000\", alpha = .8) +\n  labs(title = \"Distribution of Track Popularity by Listener\",\n       x = \"Track Popularity\", y = \"Listener\") +\n  scale_fill_manual(values = c(\"#9954FE\", \"#289832\")) +\n  theme_minimal() +\n  theme(plot.title = element_text(hjust = 0.5, face = \"bold\"),\n        panel.grid.minor = element_blank(),\n        panel.background = element_blank(),\n        axis.line = element_line(colour = \"black\"),\n        legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nI listen to the most music listed as 0 popularity, so maybe I'm more underground and edgy with my style.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nggplot(total_audio, aes(x = danceability, y = energy)) +\n  geom_point(aes(color = listener_id), alpha = .8, size = 2) +\n  labs(title = \"Comparison of Dancing Styles\",\n       x = \"Danceability\", y = \"Energy\") +\n  scale_color_manual(values = c(\"#9954FE\", \"#289832\"),\n                     labels = c(\"Erica\", \"Kiran\")) +\n  geom_text(x = .99, y = .97, label = \"Party Dancing\",\n            color = \"black\", size = 4, hjust = 1, vjust = 1) +\n  geom_text(x = 0.95, y = 0.2, label = \"Slow Dancing\",\n            color = \"black\", size = 3.5, hjust = 1, vjust = 0) +\n  geom_text(x = 0.2, y = 0.2, label = \"Chill Zone\",\n            color = \"black\", size = 3.5, hjust = 0, vjust = 0) +\n  theme_minimal() +\n  theme(plot.title = element_text(hjust = 0.5, face = \"bold\"),\n        panel.grid.minor = element_blank(),\n        axis.line = element_line(colour = \"black\"),\n        legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nWith this graph, low energy and high danceability would relate to slower (possibly romantic) songs, both of us appear to enjoy high energy and very danceable music but Kiran definitely goes harder.\n\n### Set Up Variables and Preprocessing\n\nI will be creating several machine learning models, and use these variables as the start for them all. This initial train/test split is an important step to divide the dataset in two subsets. The training data will be used throughout to build each model. The test data will only be used once for each model at the end to evaluate the performance of the model on before unseen data. Keeping the data separated avoids leakage, which happens when the final testing data has influence the building of the model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(61234)    # allows reproducibility\n\nsong_split <- initial_split(total_audio)\nsong_test <- testing(song_split) \nsong_train <- training(song_split)\n\n# Preprocessing, creating recipe with outcome and predictors\nsong_recipe <- recipe(listener_id ~ ., data = song_train) |> \n  \n  # Keep data but do not use are predictor\n  update_role(track.name, new_role = \"ID\") |>   \n  update_role(id, new_role = \"ID\") |> \n  step_rm(track.name, id) |> \n  \n  # Dummy code and normalize predictors\n  step_dummy(all_nominal(), -all_outcomes(), one_hot = TRUE) |> \n  step_normalize(all_numeric(), -all_outcomes()) |> \n  \n  prep()\n\n# Cross Validation to tune parameter\ncv_folds <- song_train |> \n  vfold_cv(v = 5)\n```\n:::\n\n\n### K Nearest Neighbors Model\n\nThis is a type of supervised machine learning algorithm used for classification and regression tasks. In this case, I will be using it as classification because we have the binary output variable of listener_id. When predicting the value of an input data point, this model looks for the \"K\" closest data points within the training set. The output prediction is based on the majority class or mean value of the K neighbors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(45634)\n\n# Define nearest neighbor model\nknn_spec <- nearest_neighbor(neighbors = 7) |> \n  set_engine(\"kknn\") |> \n  set_mode(\"classification\")\n\n# Workflow\nknn_workflow <- workflow() |> \n  add_model(knn_spec) |> \n  add_recipe(song_recipe)\n\n# Fit resamples\nknn_res <- knn_workflow |> \n  fit_resamples(\n    resamples = cv_folds,\n    control = control_resamples(save_pred = TRUE))\n\n# Check Performance\nknn_res |> collect_metrics()\n\n# Tune the hyperparameters\nknn_spec_tune <- nearest_neighbor(neighbors = tune()) |> \n  set_engine(\"kknn\") |> \n  set_mode(\"classification\")\n\n# Workflow: Define new workflow\nknn_workflow_tune <- workflow() |> \n  add_model(knn_spec_tune) |> \n  add_recipe(song_recipe)\n\n# Fit workflow on predefined folds and hyperparameters\nknn_cv_fit <- knn_workflow_tune |> \n  tune_grid(\n    cv_folds,\n    grid = data.frame(neighbors = c(1, 5, seq(10, 100, 10))))\n\n# Check performance\nknn_cv_fit |> collect_metrics()\n# Results will show the n averaged over all the folds. Use this to predict the best.\n\n# Workflow: Final\nknn_final_wf <- knn_workflow_tune |> \n  finalize_workflow(select_best(knn_cv_fit, metric = \"accuracy\"))\n\n# Fit: Final\nknn_final_fit <- knn_final_wf |> fit(song_train)\nknn_last_fit <- knn_final_wf |> last_fit(song_split)\nknn_metrics <- knn_last_fit |> collect_metrics()\n\n# Predict labels for test set\nknn_pred <- predict(knn_final_fit,\n                          new_data = song_test)\n\n# Pull out actual listener\nsong_test_true <- song_test %>%\n  select(listener_id)\n\n# Evaluate model performance on test set\nknn_perf <- knn_pred %>%\n  bind_cols(song_test_true)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# View predicted and actual listeners\nknn_perf |> \n  select(Predicted = .pred_class, Actual = listener_id) |> \n  slice(1:10) |> \n  kable()\n```\n\n::: {.cell-output-display}\n|Predicted |Actual |\n|:---------|:------|\n|erica     |erica  |\n|erica     |erica  |\n|erica     |erica  |\n|erica     |erica  |\n|erica     |erica  |\n|erica     |erica  |\n|erica     |erica  |\n|kiran     |erica  |\n|erica     |erica  |\n|erica     |erica  |\n:::\n\n```{.r .cell-code}\nknn_perf |> \n  metrics(truth = listener_id, estimate = .pred_class)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 3\n  .metric  .estimator .estimate\n  <chr>    <chr>          <dbl>\n1 accuracy binary         0.692\n2 kap      binary         0.378\n```\n:::\n:::\n\n\n### Decision Tree\n\nThe next two models, bagging and random forests, use a series of decision trees. Decision tree models begin with all the data in a root node and making a split based on the most significant feature. Each split results in nodes of data to split on another feature, until there are finally no features left to split the data on. The model makes predictions by following the path from the root node to a leaf node following the rules set by each node split.\n\n### Bagging\n\nBagging is a form of bootstrap aggregation, this means that this is an ensemble model. The model constructs multiple versions of the same base model using random samples of the training data. All of these sub-models are aggregated into a final model. These steps improve the model performance by reducing variance and overfitting.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(4657345)\n\n# Tune specs\ntree_spec_tune <- bag_tree(\n  mode = \"classification\",\n  cost_complexity = tune(),\n  tree_depth = tune(),\n  min_n = tune()) |> \n  set_engine(\"rpart\", times = 50)\n\n# Define tree grid\ntree_grid <- grid_regular(cost_complexity(), tree_depth(), min_n(), levels = 5)\n\n# New workflow\nwf_tree_tune <- workflow() |> \n  add_recipe(song_recipe) |> \n  add_model(tree_spec_tune)\n\n# Build each model in parallel\ndoParallel::registerDoParallel()\n\n# Fit model\ntree_rs <- wf_tree_tune |>\n  tune_grid(listener_id ~ .,\n    resamples = cv_folds,\n    grid = tree_grid,\n    metrics = metric_set(accuracy))\n\n# Final workflow\nfinal_bag <- finalize_workflow(wf_tree_tune, select_best(tree_rs, \"accuracy\")) |> \n  fit(data = song_train)\n\n# Predictions\nbag_pred <- final_bag |> \n  predict(new_data = song_test) |> \n  bind_cols(song_test)\n\n# Save metrics\nbag_metrics <- bag_pred |> \n  metrics(truth = listener_id, estimate = .pred_class)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# View predicted and actual listeners\nbag_pred |> \n  select(Predicted = .pred_class, Actual = listener_id) |> \n  slice(1:10) |> \n  kable()\n```\n\n::: {.cell-output-display}\n|Predicted |Actual |\n|:---------|:------|\n|erica     |erica  |\n|erica     |erica  |\n|erica     |erica  |\n|erica     |erica  |\n|erica     |erica  |\n|kiran     |erica  |\n|erica     |erica  |\n|kiran     |erica  |\n|erica     |erica  |\n|kiran     |erica  |\n:::\n\n```{.r .cell-code}\n# Evaluate performance\nbag_pred |> \n  metrics(truth = listener_id, estimate = .pred_class)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 3\n  .metric  .estimator .estimate\n  <chr>    <chr>          <dbl>\n1 accuracy binary         0.730\n2 kap      binary         0.455\n```\n:::\n:::\n\n\n### Random Forest\n\nRandom forest is another ensemble model, but this one cannot be done in parallel. This method creates multiple decision trees on random subsets of the data, and the key difference with this model is the random selection of features to include for each model. Not using all the features in each model then combining the decision trees improves the accuracy of the model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define validating set\nset.seed(1368)\nval_set <- validation_split(song_train, \n                            strata = listener_id, \n                            prop = 0.70)\n\n# Create Random Forest specification\nrf_spec <-\n  rand_forest(mtry = tune(),\n              min_n = tune(),\n              trees = 1000) %>%\n  set_engine(\"ranger\") %>%\n  set_mode(\"classification\")\n\n# Define Random Forest workflow\nrf_workflow <- workflow() %>%\n  add_recipe(song_recipe) %>%\n  add_model(rf_spec)\n\n# Build in parallel\ndoParallel::registerDoParallel()\nrf_res <- \n  rf_workflow %>% \n  tune_grid(val_set,\n            grid = 25,\n            control = control_grid(save_pred = TRUE),\n            metrics = metric_set(accuracy))\n\n# Output model metrics\nrf_res %>% collect_metrics()\n\n# Find the best accuracy metric\nrf_res %>% \n  show_best(metric = \"accuracy\")\n\n# Plot results\nautoplot(rf_res) +\n  theme_minimal()\n```\n\n```{.r .cell-code}\n# Select best Random Forest model\nbest_rf <- select_best(rf_res, \"accuracy\")\n\n# Output predictions\nrf_res %>% \n  collect_predictions()\n\n# Defining final model while working in parallel\ndoParallel::registerDoParallel()\nlast_rf_model <- \n  rand_forest(mtry = 2, min_n = 3, trees = 1000) %>% \n  set_engine(\"ranger\", importance = \"impurity\") %>% \n  set_mode(\"classification\")\n\n# Update workflow\nlast_rf_workflow <- \n  rf_workflow %>% \n  update_model(last_rf_model)\n\n# Update model fit\nrf_final_fit <- last_rf_workflow |> fit(song_train)\n\nlast_rf_fit <- \n  last_rf_workflow %>% \n  last_fit(song_split)\n\n# Output model metrics\nrandom_forest_metrics <- last_rf_fit %>% \n  collect_metrics()\n\n# Predict on test set\nrf_pred <- predict(rf_final_fit,\n                     new_data = song_test) |> \n  bind_cols(song_test)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Output the variables that are most important to our model\nlast_rf_fit %>% \n  extract_fit_parsnip() %>% \n  vip(num_features = 12) +\n  ggtitle(\"Variable Importance Plot\") +\n  theme(plot.title = element_text(hjust = 0.5)) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# View predicted and actual listeners\nrf_pred |> \n  select(Predicted = .pred_class, Actual = listener_id) |> \n  slice(1:10) |> \n  kable()\n```\n\n::: {.cell-output-display}\n|Predicted |Actual |\n|:---------|:------|\n|erica     |erica  |\n|erica     |erica  |\n|erica     |erica  |\n|erica     |erica  |\n|kiran     |erica  |\n|erica     |erica  |\n|erica     |erica  |\n|kiran     |erica  |\n|erica     |erica  |\n|erica     |erica  |\n:::\n\n```{.r .cell-code}\n# Evaluate performance\nrf_pred |> \n  metrics(truth = listener_id, estimate = .pred_class)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 3\n  .metric  .estimator .estimate\n  <chr>    <chr>          <dbl>\n1 accuracy binary         0.730\n2 kap      binary         0.453\n```\n:::\n:::\n\n\n### Comparing Metrics\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# nearest neighbors metrics\nknn_accuracy <- knn_metrics$.estimate[1]\n \n# bag tree metrics\nbag_accuracy <- bag_metrics$.estimate[1]\n\n# Random Forest metrics\nrf_accuracy <- random_forest_metrics$.estimate[1]\n\n\nmodel_accuracy <- tribble(\n  ~\"model\", ~\"accuracy\",\n  \"KNN\", knn_accuracy,\n  \"Bagging\", bag_accuracy,\n  \"Random Forest\", rf_accuracy\n)\n\nggplot(data = model_accuracy, aes(x = model, y = accuracy)) +\n         geom_col(fill = \"gray\") +\n  theme_minimal() +\n  labs(title = \"Comparison of Model Accuracy for Spotify Data\",\n       x = \"Model\", y = \"Accuracy\") +\n  theme(plot.title = element_text(size = 16, face = \"bold\"),\n        axis.title = element_text(size = 12),\n        axis.text = element_text(size = 10)) +\n  ylim(0,1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}